###############
ASYNC FUNCTIONS
###############

Removes the hassle of nested callbacks, promise chains, multiple yield statements and generator functions.

The goals is to simplify asynchronous code, especially the handling of promises.

The word “async” before a function means one simple thing: a function always returns a promise. Other values are wrapped in a resolved promise automatically.

async function sayHello(){return "Hello";}

sayHello() 	//-> Promise {<resolved>: "Hello"}

sayHello().then(val => console.log(val);
	
// -> Hello -> Promise {<resolved>: undefined}

The AWAIT keyword pauses the execution of the async function, and is followed by a promise. AWAIT waits for the promise to resolve. It resumes the function once the the promise is resolved and returns the resolved value.

Because of the pause button you write async code that reads as if it were synchronous.

When we use async/await, we rarely need .then, because await handles the waiting for us. And we can use a regular try..catch instead of .catch. That’s usually (but not always) more convenient.

EXAMPLE

async function f() {
	let promise = new Promise((resolve, reject) => {
    	setTimeout(() => resolve("done!"), 1000)
  	});

	let result = await promise; 

	console.log(result);
}
f();	//-> 	Promise{pending}
		done! (after one second)

Let’s emphasize: await literally makes JavaScript wait until the promise settles, and then go on with the result. That doesn’t cost any CPU resources, because the engine can do other jobs in the meantime: execute other scripts, handle events, etc.

It’s just a more elegant syntax of getting the promise result than promise.then, easier to read and write.

TOP LEVEL CODE

Can’t use await in top-level code. For example, this will not work because await needs to be part of an async function.

// syntax error in top-level code
let response = await fetch('/article/promise-									chaining/user.json');
let user = await response.json();

But we can wrap it into an anonymous async function, like this:

(async () => {
	let response = await fetch('/article/promise-						chaining/user.json');
  	let user = await response.json();
})();


ERROR HANDLING

AWAIT assumes the promise will be resolved correctly. To handle rejections use TRY/CATCH keywords. JS itself will generate an error. Just add a TRY/CATCH block. 

async function f() {
	try {
    		let response = await fetch('http://no-such-url');
		let user = await response.json();
  	} catch(err) {
    		alert(err); // TypeError: failed to fetch
  	}
}
f();

If we don’t have try..catch, then the promise generated by the call of the async function f() becomes rejected. We can append .catch to handle it:
f().catch(err => console.log(err));






EXERCISE REWRITE

function loadJson(url) {
  return fetch(url)
    .then(response => {
      if (response.status == 200) {
        return response.json();
      } else {
        throw new Error(response.status);
      }
    })
}

loadJson('no-such-user.json')
  .catch(alert); // Error: 404


async function loadJson(url){
	try {
		let response = await fetch(url);
		if(response.status == 200){
			let json = await response.json();
			return json;		
		}
	}
	catch (err){
		console.log(response.status, err);
	}
}

EXAMPLE CALL ASYNC FUNCTION INSIDE A REGULER FUNCTION

async function wait() {
  await new Promise(resolve => setTimeout(resolve, 1000));

  return 10;
}

function f() {
  // ...what to write here?
  // we need to call async wait() and wait to get 10
  // remember, we can't use "await"
}

SOLUTION

function f(){
	wait()
		.then(result => console.log(result))
		.catch(err => console.log(err));
}
f();	//-> 10 after 1 second