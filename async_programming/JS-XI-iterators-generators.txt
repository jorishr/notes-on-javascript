########################
ITERATORS AND GENERATORS
##########################################
I.	ITERATORS
II.	EXTRACT THE ITERATOR
III.	GENERATOR FUNCTIONS
	A.	GENERATORS
	B.	COMBINE GENERATORS
	C.	USE CASE: ASYNC HTTP REQUESTS
	D.	LOOP GENERATOR FUNCTION VALUES
##########################################


###############
I.	ITERATORS
###############

Arrays are easily iterable because of their ordered structured with an index based positioning.

Objects however are more difficult to iterate over because the key-value pairs don't come in a specific order.

How to find if a datastructure is iterable?

SYMBOL ITERATOR

Modern JS has introduced the Symbol iterator object which is present in datastructures that are iterable only.

let arr = [1,2,3];
let obj = {a: 1, b: 2, c: 3};

console.dir(arr)		//-> _proto_ -> Symbol(Symbol.iterator)
console.dir(obj)		//-> 	No Symbol object


ITERABLES DATASTRUCTURES are:
- strings,
- arrays,
- sets and weak sets,
- maps and weak maps

ITERABLES AND FOR...OF
The symbol iterator allows us to use a new sort of loop on iterable datastructures.

let mySet = new Set[1,2,3,4,4,4,5];
mySet		//-> [1,2,3,4,5]	duplicate item are ignored

for(let val of mySet){console.log(val)}	//-> 1,2,3,4,5

The classic for loop can be shortened:

for(let i=0; i < arr.length; i++){
	console.log(i);
};

becomes:

for(let val of arr){console.log(i)}


##########################
II.	EXTRACT THE ITERATOR
##########################

Store a CALL to the ITERATOR function in a variable.

let arr = [1,2,3];
let iterator = arr[Symbol.iterator]();
iterator	//->	Array Iterator	-> __proto__ -> f next()

The ITERATOR has a NEXT function that will allow you to obtain the next value in the iterating process.

If you call that method, you get an object with two key-value pairs: the next value in the datastructure and a boolean that indicates whether or not the iteration has ended.

iterator.next()	//-> {value:1, done: false}
iterator.next()	//-> {value:2, done: false}
iterator.next()	//-> {value:3, done: false}
iterator.next()	//-> {value:undefined, done: true}


########################
III.	GENERATOR FUNCTION
########################

A.	GENERATOR FUNCTION

A generator function build on top of the Symbol.iterator implementation. 

function* myGenerator(){
	yield 1;
	yield 2; 
}

myGenerator()	//-> {<suspended>}

myGenerator.next(); 	//-> {value: 1, done: false};

let generator = myGenerator();

generator.next() 	//-> {value: 1, done: false};
generator.next() 	//-> {value: 2, done: false};
generator.next() 	//-> {value: undefined, done: true};

Upon each call, it pauses and yields a value. Only upon the next call it goes on to yield the next value.

Thus even an infinite generator with a while loop will not overflow the stack.

function* infinite(){
	let i = 0;
	while(true){
		yield(i);
		i++
	}
}

infinite()		//->	{<suspended>}

let iterator = infinite();

iterator.next()	//-> {value:1, done: false}
iterator.next()	//-> {value:2, done: false}
iterator.next()	//-> {value:3, done: false}
iterator.next()	//-> {value:4, done: false}
...

The value for done will never become true.


B.	COMBINE GENERATORS

function* generator(){
	yield 1;
	yield* anotherGenerator();
	yield 3;
}

function* anotherGenerator(){
	yield 2;
};

let generate = generator();

generate.next()	//-> {value:1, done: false}
generate.next()	//-> {value:2, done: false}
generate.next()	//-> {value:3, done: false}
generate.next()	//-> {value:undefined, done: true}


C.	USE CASE: DEPENDENT ASYNC HTTP REQUESTS

If you have multiple http requests that depend on the data that retrieved by a previous ajax call, generators are very useful because that pause the execution untill the data is returned.

function* generator(){
	yield request('url1');
	yield request('url2');
}

function request(url){
	return new Promise(function(resolve, reject){
		ajaxCall(url, function(err, data){
			if(err) reject(err);
			else resolve(data);
		})
	})
}

SEE EXERCISE EXAMPLE


D.	LOOP GENERATOR FUNCTION VALUES

Generators implement a Symbol.iterator property that we can use to iterate over the various VALUE properties(yields) that are generated by the respective yield objects.

for(val of myGenerator()){console.log(val)} whereby val takes on the VALUE property value of the generated object {value: <x>, done: <boolean>}

With this step you don't have to manually invoke .next() all the time to access the VALUE property. If you do want the entire object, you obviously would have to call .next()
