# Async function in Javascript
Table of contents
- [Async function in Javascript](#async-function-in-javascript)
	- [Async](#async)
	- [Await](#await)
	- [Error handling](#error-handling)
	- [Fetch API example refactor](#fetch-api-example-refactor)
	- [Async inside a regular function](#async-inside-a-regular-function)
## Async
Asynchronous function are meant to removes the hassle of nested callbacks, promise chains, multiple yield statements and generator functions. 

The keyword `async` before a function means one simple thing: a function always returns a promise. Other values are wrapped in a resolved promise automatically.
```js
async function sayHello(){
	return "Hello";
}
sayHello() 	
//-> Promise {<resolved>: "Hello"}

//consume the promise
sayHello().then(val => console.log(val);
//-> Hello 
//-> Promise {<resolved>: undefined}
```
## Await
The AWAIT keyword pauses the execution of the async function, and is followed by a promise. AWAIT waits for the promise to resolve. It resumes the function once the the promise is resolved and returns the resolved value. Because of the pause button you write async code that reads as if it were synchronous.

When we use async/await, we rarely need the then consumer method, because await handles the waiting for us and we can use a regular `try..catch` block instead. That's usually (but not always) more convenient.

```js
async function f() {
	let promise = new Promise((resolve, reject) => {
    	setTimeout(() => resolve("done!"), 1000)
  	});

	let result = await promise; 

	console.log(result);
}
f();	
//-> 	Promise{pending}
//->	done! (after one second)
```
Let's emphasize: await literally makes JavaScript wait until the promise settles, and then goes on with the result. That doesn't cost any CPU resources because the engine can do other jobs in the meantime: execute other scripts, handle events, etc. It's just a more elegant syntax of getting the promise result instead of `promise.then` and easier to read and write.

The await keyword cannot be used in top-level code. It always needs to be wrapped into an async function.
```js
// syntax error in top-level code
let response = await fetch('/article/promise-									chaining/user.json');
let user = await response.json();

//wrapped in an anonymous async function:
(async () => {
	let response = await fetch('/article/promise-chaining/user.json');
  	let user = await response.json();
})();
```
## Error handling
The await keyword assumes the promise will be resolved correctly. To handle rejections use the TRY/CATCH block. If we don't have try..catch, then the promise generated by the call of the async function f() becomes rejected. We can append catch to handle it:
```js
async function f() {
	try {
  		let response = await fetch('http://no-such-url');
		let user = await response.json();
  	} catch(err) {
    	alert(err); // TypeError: failed to fetch
  	}
}
f();

//or

f().catch(err => console.log(err));
```
## Fetch API example refactor
```js
//base version
function loadJson(url) {
  return fetch(url)
    .then(response => {
      if (response.status == 200) {
        return response.json();
      } else {
        throw new Error(response.status);
      }
    })
}

loadJson('no-such-user.json').catch(alert); // Error: 404

//async version
async function loadJson(url){
	try {
		let response = await fetch(url);
		if(response.status == 200){
			let json = await response.json();
			return json;		
		}
	}
	catch (err){
		console.log(response.status, err);
	}
}
```
## Async inside a regular function
```js
async function wait() {
  await new Promise(resolve => setTimeout(resolve, 1000));
  return 10;
}
function f() {
  // ...what to write here?
  // we need to call async wait() and wait to get 10
  // remember, we can't use "await"
}

//solution
function f(){
	wait()
		.then(result => console.log(result))
		.catch(err => console.log(err));
}
f();	//-> 10 after 1 second