#########################
OOP: THE PROTOTYPE OBJECT
##############################################
I.	PROTOTYPE OBJECT OF CONSTRUCTOR FUNCTION
	A.	DUNDER PROTO
	B.	DEFINING AND SHARING METHODS
	C.	PROTOTYPE CHAIN
II.	EXAMPLES
##############################################

##############################################
I.	PROTOTYPE OBJECT OF CONSTRUCTOR FUNCTION
##############################################

Each constructor function has a property called .prototype,
an object with a property constructor and value f. The value f refers to the actual consrtructor function.

ConstructorFn.prototype		//-> {constructor: f}
	

A.	DUNDER PROTO

Each object instance that is created by a constructor function has a link __proto__ (dunder proto) property that refers to the prototype of the constructor function. This link is created by the new keyword. 

function Person(name){this.name = name;}

let person1 = new Person("Joris")

person1 //-> Person {name: "Joris"} ---an object with one property name: "Joris"

person1.__proto__ //-> {constructor: ƒ}

The newly created object is given a dunder proto property by the new keyword, which points to the prototype property of the constructor function.
Thus:

person1.__proto__ === Person.prototype		//->true

NOTE: the constructor function prototype property (Person.prototype) also has a property itself called .constructor which points back to the function itself:

Person.prototype.constructor //->ƒ Person(name){}


B.	DEFINING AND SHARING METHODS THROUGH PROTOTYPE PROPERTY

Adding methods and properties to the prototype object of a constructor function can make your code more efficient.

The prototype property on a constructor function is shared with all the objects that are created from that constructor function. 

The "sharing" is made possible through the dunder.__proto__ property on each created object.

This means that every method or property created ON the constructor prototype property is also accesible by every object created by the constructor function:

	Person.prototype.propertyOnTop = "hello" 
	person1.propertyOnTop // "hello"
	person2.propertyOnTop // "hello"


C.	PROTOTYPE CHAIN

This is exactely how JS finds methods and property on objects. If the method or property is not present directly inside the object it'll go to the __proto__ because all objects that are created in JS have this __proto__ as they all are somehow created by a "new keyword + constructor function".

let array = []; is shorthand for:
new Array //-> with Array being a built-in JS function

To find the push method that is present on all arrays the PROTOTYPE CHAIN is followed:

arr.push(10) //-> [10]
console.dir(arr) //-> [10]- 0: 10 -lenght: 1 -__proto__:Array(0)

The .push is not directly found in the object arr. But if you look inside the __proto__ of the array what you see is actually the Array.prototype with all the associated methods and properties in it: push, filter, indexOf, slice, forEach, etc,
BECAUSE array.__proto__ === Array.prototype

NOTE: if the method is not found in the PROTOTYPE CHAIN, it evaluates as undefined


DISSECTING OBJECTS

The FIRST __proto__ you'll find inside an object	will refer to the constructor function prototype. 

If you go another level deeper you get to the OBJECT PROTOTYPE. 

Thus:

Person.prototype.__proto__ === Object.prototype //-> true

Object.prototype.__proto__ //-> null END of the PROTOTYPE CHAIN 

NOTE: Object.prototype provides a few methods that show up in all objects, such as .toString, which converts an object to a string representation. 

Many objects don’t directly have Object.prototype as their main prototype but instead have another object that provides a different set of default properties:

- Functions draw first from the Function.prototype and 
- Arrays draw first from the Array.prototype

dir(Math.max) //-> __proto__: f ()
				__proto__: Object()

Math.max.__proto__ === Function.prototype //-> true

In sum, the prototype property of a constructor function is an excellent place to put methods and properties we want to share with the objects we create from the constructor function.


##############
II.	EXAMPLES
##############

EXAMPLE 1:

Creating a couple of "persons" from the constructor function Person is straigthforward but adding a property to hundreds of objects is timeconsuming and this can be automated:

function Person(name){this.name: name};

Person.prototype.sayHi = () => "Hi ," + this.name;
	
person1 = new Person("name1");
person.sayHi() //"Hi name1";


EXAMPLE 2:

Create a constructor function for verhicles with properties: make, model, year and isRunning set to false. Those are not function(methods) that have to be shared by all the objects that are going to be created by this function. 

Thus, they go inside the constructor function. You call the constructor function with keyword new and store the resulting value(object) inside a binding.

function CreateVehicle(make, model, year){
	this.make = make;
	this.model = model;
	this.year = year;
	this.isRunning = false;
}
car1 = new CreateVehicle("Mercedes", "E-class", 2012)
etc...

Create methods that work on all objects that change the value of of the isRunning property:
	
CreateVehicle.prototype.turnOn = () => this.isRunning = true;
CreateVehicle.prototype.turnOff = () => this.isRunning = false;

car1.turnOn()
car1.turnOff()

A method that returns a string ONLY if .isRunning is true

CreateVehicle.prototype.honk = () => if(this.isRunning){return "beep"}}

car1.honk() // -> "beep"