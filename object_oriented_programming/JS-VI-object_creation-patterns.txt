########################
OBJECT CREATION PATTERNS
###############################
I.	FACTORY PATTERN
II.	CONSTRUCTOR PATTERN
III.	PROTOTYPE PATTERN
IV.	DYNAMIC PROTOTYPE PATTERN
###############################

No formal CLASS support in JS, thus the behavior of classes is mimicked. Basically, you create Objects and create new objects from those objects.


#####################
I.	FACTORY PATTERN
#####################

You create a FACTORY function that returns an object. First you declare the object, then add properties and methods.

function personFactory(name, age, email){
	let person = {};
	
	person.name  = name;
	person.age	  = age;
	person.email = email;

	person.print = () => console.log(`${person.name}, ${person.age}, ${person.email}`)

	return person;	
}

var person1 = personFactory('John', 20, 'john@doe.com');
var person2 = personFactory('Jane', 18, 'jane@doe.com');


person1.print();		//-> John, 20, john@doe.com
person2.print();		//-> Jane, 18, jane@doe.com


#########################
II.	CONSTRUCTOR PATTERN
#########################

The pattern is similar to the factory pattern but you make use of the THIS and NEW keywords.

The constructor function itself does not return anything. Thus we use the NEW keyword to create a new excution context for each new Person that is created.

function personConstructor(name, age, email){
	
	this.name	= name;
	this.age 	= age;
	this.email = email;

	this.print = function(){console.log(`${this.name}, ${this.age}, ${this.email}`)}
}

const person1 = new personConstructor('John', 20, 'john@doe.com');
const person2 = new personConstructor('Jane', 18, 'jane@doe.com');

person1.print();		//-> John, 20, john@doe.com
person2.print();		//-> Jane, 18, jane@doe.com



#######################
III.	PROTOTYPE PATTERN
#######################

The issue with the constructor pattern is that for each new object that is created, all the defined properties and methods get stored into the object.

This can lead to bloated objects that take up too much memory space. Especially the print function in the example is a good candidate to move out of the individual objects and move to the prototype property. When you have thousands of user objects you want them to be as lightweight as possible.

The constructor function does nothing but we can define shared properties for all object instances that will be created by that funciton using the keyword new.

An advantage is also that you can specify default values.

function personProto(){};

personProto.prototype.name 	= 'no name';
personProto.prototype.age 	= 0;
personProto.prototype.email	= 'no email';
personProto.prototype.print	= function(){console.log(`${this.name}, ${this.age}, ${this.email}`)}

const person1 = new personProto();
person1.print()	//-> no name, 0, no emai

person1	//	-> personProto {} 
			->__proto__: name: 'no name' age: 0, email: 			'no email', print: f ();

console.log('name' in person1)	//-> true
console.log('age' in person1)	//-> true
console.log('email' in person1)	//-> true
console.log('print' in person1)	//-> true

The defined properties and methods are now available for every instance of the personProto function, even if they are not explicitely declared onto the object itself. Person1 is an empty object. The property values are stored in and retrieved from the prototype. 

Once you explicitely set values for the instance of the object you created, they become part of the actual object: 

person1.name  = 'John'
person1.age   = '20'
person1.email = 'john@doe.com'
person1.print()	//-> John, 20, john@doe.com

person1	//-> personProto {name: 'John', age: 20, email: ''}

HAS OWN PROPERTY
To test whether a property on an object is available through the prototype or directly set on the object use hasOwnProperty method:

console.log(person1.hasOwnProperty('name'))		//-> true
console.log(person1.hasOwnProperty('print'))	//-> false
console.log('print' in person1)				//-> true

Thus the print function is a property available to the person1 object but stored in the prototype dunder proto and not the object itself.


###############################
IV.	DYNAMIC PROTOTYPE PATTERN
###############################

This disadvantage with creating object instances through a manual prototype pattern is that you have to create an empty object and manually modify the properties. 

To do this in a dynamic way you can combine the constructor and prototype pattern.

function(name, age, email){
	this.name	= name;
	this.age 	= age;
	this.email = email;
}
 