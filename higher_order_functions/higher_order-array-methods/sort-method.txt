###########
SORT METHOD
###########################################################
I.	PARAMETER
II.	FUNCTION LOGIC
III.	SORTING/COMPARING NUMBERS
IV.	SORTING STRING VALUES
V.	ADVANCED SORTING
	A.	BASED ON A VALUE INSIDE EACH ARRAY ELEMENT
	B.	TIEBREAKER SORT
	C.	CONCAT AND SORT ARRAYS
###########################################################

REFERENCE:
https://css-tricks.com/level-up-your-sort-game/

While many of the ES5 array methods such as .filter, .map, and .reduce will return a new array and leave the original untouched, .sort will sort the array IN PLACE.

To create a new array use the SPREAD operator:
	
	let arr 	= [a, c, b];
	let arrSorted = arr.sort();
		-> [a, b, c];
	let newArr = [...arr].sort();


###############
I.	PARAMETER
###############

The .sort(compareFn) only has one parameter: a comparison function that accepts two parameters itself. 
	
	.sort(compareFn(a, b){});

a and b are the two elements that we will be comparing. 

If you do not provide a comparison function, the array will coerce each element into a STRING and sort according to Unicode points.

let arr = [1, 4, 3, 22, 12, 44, 6];
Thus arr.sort() becomes: [1, 12, 22, 3, 4, 44, 6].

To solve this you need to provide a function: See III.

####################
II.	FUNCTION LOGIC
####################

If you would like the a to be ordered first in the array, the comparison function should return a NEGATIVE integer; 

for b, a POSITIVE integer. 

If you would like the two to maintain their current order, return a 0.


###############################
III.	SORTING/COMPARING NUMBERS
###############################

Applying the above logic: if the a value is bigger than the b value, the result is a POSITIVE INTEGER, thus the b-value gets moved before the a-value.

Thus, 5-2 will result in [2,5]; and 3-6 will result in [3, 6].
 
	const numbers = [13,8,2,21,5,1,3,1];

	const sorted = [...numbers].sort((a,b) => a - b;);
	
	console.log(sorted); // [1,1,2,3,5,8,13,21]


###########################
IV.	SORTING STRING VALUES
###########################

When comparing strings, the > and < operators will compare values based on each string’s Unicode value.

Simple example: 

	arr.sort((a,b) => a > b;);

Advanced: 

You parse the innerText strings into a number. To make the comparion work both ways (A-Z, Z-A) the ternary operator is used.

Thus if 
	aa > bb results in -1, thus [...,aa, bb,...]
	aa < bb or aa == bb results running the next ternary 	operator:

		aa < bb ? 1 : 0; 
			thus [...,bb,aa,...] or [...,aa,bb,...]
	
let sortedArr = currentListArr.sort(function(a, b){
	let aa = parseInt(a.innerText);
	var bb = parseInt(b.innerText);
    	return aa > bb ? -1 : (aa < bb ? 1 : 0);
});

Possible problems that may arise: case sensitivity and special characters.

JavaScript does have a method to help with comparing strings: the String.prototype.localeCompare method. 

referenceStr.localeCompare(compareString[, locales[, options]])

This method accepts:
	- a comparison string, 
	- a locale, 
 	- and an options object. 

The localeCompare() method returns a number indicating whether a reference string comes before or after or is the same as the given string in the sort order.

The new locales and options arguments let applications specify the language whose sort order should be used and customize the behavior of the function.

EXAMPLE

	const strings = ["a","A","Ä","b","Bb","ë","é"];

// helper function that takes as parameter the possible values of localeCompare(base, case, accent, variant, etc);
 
function (sensitivity) {
  return function (a, b) {
    return a.localeCompare(
		b, 
		undefined, 
    		{sensitivity: sensitivity});
  };
};
// locale string -- undefined means to use browser default

const byBase = sortBySensitivity('base');	// 
const byBase = sortBySensitivity('case')	//

	const baseSorted = [...strings].sort(byBase);
	const caseSorted = [...strings].sort(byCase);

######################
V.	ADVANCED SORTING
######################

A.	BASED ON A VALUE INSIDE EACH ARRAY ELEMENT

The classic example is an array of objects, one of the properties of each array element is price and you want the elements of the array sorted on price.

	const products = [{name: "a", price: 20},{name: "b", price: 			10},{name: "c", price: 30}] 

The comparisonFn is straigthforward for comparing numbers, to access the price property use another helper function:

	const compareValue = (a,b) => a - b;
	const getPrice = e => e.price;

Next you need to create a helper function that takes in as parameters: a map to the price value(getPrice)and the comparisonFn(compareValue) for the .sort() method. 
	
	const sortByPrice = sortByMapped(getPrice, compareValue);

	const sortByMapped = 
	(map, compareFn) => (a,b) => compareFn(map(a), map(b))

Thus the sortByMapped function indicates which map to follow to get to the values that have to be compared inside the sort() method.

	const sortedProducts = [...products].sort(sortByPrice);

ANOTHER EXAMPLE

Sort an array of dates.

	const dates  = ['2018-12-10', '1991-02-10', '2015-10-07', 			'1990-01-11'];

Here the strings in the array are used to create a date reference with new Date() method.

The map function is the same.

	const sortByMapped = (map,compareFn) => (a,b) => 					compareFn(map(a),map(b));
	const toDate = e => new Date(e).getTime();
	
	const byValue = (a,b) => a - b;
	
	const byDate = sortByMapped(toDate,byValue);

	const sortedDates = [...dates].sort(byDate);
	

B.	A TIEBREAKER SORT

See article reference.


C.	CONCAT AND SORT ARRAYS	

const a = [1, 3, 5, 7]
const b = [0, 2, 4, 6, 8, 9, 10, 11]

const c = a.concat(b);//-> [1, 3, 5, 7, 0, 2, 4, 6, 8, 9, 10, 11]

To sort it correctly:

const c = a.concat(b).sort((x, y) => x - y);

There are however more efficient ways to do so by using a method that would only take the elements of a, compare them manually to index positions in b and then stop the comparison after the last element.

Now .sort() will resort all the elements of a and b.