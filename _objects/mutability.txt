##########
MUTABILITY
##########

################################
I.	IMMUTABLE PRIMITIVE VALUES
################################

Strings, boleans and numbers are immutable, there values cannot be changed. The code for number 22 is 22 and the code for "hello" is "hello". You can operate on strings, boleans and number to create new values, but that does not affect the original. Thus two number 10 and 10 are precisely the same number, whether or not they refer to the same physical bits.

For example, if you try to add properties to a binding that holds a string, this is not stored:
	let name = "first name";
	name.surname = "last name";
	console.log(name.surname) //undefined

Strings, numbers and boleans only have built-in properties that hold function values, i.e methods. .length, .slice, etc.


######################
II.	OBJECT MUTABLITY
######################

Objects (and thus arrays) however, can have their properties changed so that a single object can have different properties at different times.

	let object1 = {a: 5};
	let object2 = object1; 

	let object3 = {a: 5};

let object2 = object1; does NOT create new object. We create or assign a NEW REFERENCE to an existing object! 

Object3 contains the same property with the same value as object1 (and object2) BUT it lives a seperate life because the binding refers to a different object. 

With let object3 = {a: 5}; we DO create a new object. 

The difference has important consequences: if you change a property using the reference object1 OR object2 you will modify the exact same object.

Thus: 
object2.a = 10; 
object1; // -> -> {a: 10}
object2; // -> -> {a: 10}

object1.b = "hello";
object2.b; // -> "hello"

Object1 and object2 have the same IDENTITY. Thus the property and value of object2 can be considered precisely the same the way the number 10 is 10. Not so for object3.

If you would change the property of object1, that changes the property of object2, not object3.
	object1.a = 10;
	console.log(object2.a); //10

Thus object1 == object2 //true
But  object1 == object3 //false, because == checks for identity

NOTE: if you use the const binding for an object you cannot change the entire binding to that object. You can only update the properties.

	const objectScore = {home: 0, visitors: 0};
	objectScore.home = 1; //allowed
	objectScore = {home: 1, visitors: 1}: //incorrect

Takeaway: an object NAME is not the object itself. It is a REFERENCE to the object stored in the computers memory.