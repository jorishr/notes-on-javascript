###############################
EJS CHAPTER IV: DATA STRUCTURES
###############################
OBJECTS
I.	ABOUT OBJECTS
	A. ARRAYS
	B. ARRAY LIMITATIONS
	C. ARRAYS vs OBJECTS
II.	MODIFYING OBJECT PROPERTIES
III.	OBJECT METHODS
	A.	OBJECT.KEYS
	B.	OBJECT.ASSIGN
	C.	FREEZE/SEAL/DEFINE PROPERTY
	D.	CUSTOM OBJECT METHODS
	E.	KEYWORD THIS
########################################


################
I. ABOUT OBJECTS
################

Objects are abitrary collections or groups of properties. Those properties can be nouns, adjectives and verbs that describe the properties and actions you can undertake with the object.

const car = {color: 'red', getin: function(){}, parked: true}
Here color and parked are nouns, that use an adjective 'red' and a verb parked to describe the state of the car. The verb getin describe an action defined by a function.

Thus object1 is a collection of the properties a, b and c that hold the values false (bolean), 22 (number), ["yellow", "red"](an array of strings):
	
let object1 = {
	a: false,
	b: 22,
	c: ["yellow", "red"]
};

You can access those properties:

console.log(object1.a); //->false


A.	ARRAYS ARE OBEJCTS

Thus arrays are objects with properties that have zero-based number names.

	let array = ["hello", 22, false]; 

could be tought of as:

	let array = {
		0: "hello",
		1: 22,
		2: false	
	}

In the console typeof [] will return object.

Because of the index based naming it is especially useful for storing a sequence of things. 

Since you can store objects inside objects it is possible to create an array of objects. 

	let array = [
		{property1: value, property2: value, property3: 				value},
		{property1: value, property4: value},
		{property5: value, property6: value}	
	]
NOTE: first object is stored on index position 0, or in the first property of the array.

Practical example: A journal whereby you have entries every day. Inside every day you have activities and a result(bolean).
Thus you can have an array of days that hold an object with the properties: activities and result:

let journal = [
	{activity: ["work", "swim"], result: true}, //day 1, index 0
	{activity: ["run", "write], result: false}, //day 2, index 1
	{activity: ["walk", "work"], result: true}	//day 3, index 2 
]


B.	ARRAY LIMITATIONS

Use an array for a variable person = ["name", "age", "city"] does not have a meaningful order. To access "city", you need to know this index position 2, and if you make changes to the array, the position might change.

That's where OBJECTS come in. Objects don't have a built-in order, so there is no index position for each property (or key-value pair), it doesn't matter in which order you declared
them.

var object = {    		THUS var person {
  property: "value",          name: "Joris",
  property: "value",          age: "35",
  property: "value"           city: "Sant Cugat"
}                      	}

Retrieving data can be done via dot OR bracket notation:
	
	console.log(object.property); 
	console.log(person.name) 		//-> "Joris"

	console.log(object["city"]);
	console.log(person["city"]); 	//-> "Sant Cugat"

Its is easier to use dot notation BUT that does not work with properties that start with a NUMBER or that contain spaces.

Update data inside object:

person.age = 35;
person.age = += 2; OR person["age"] += 4;


C.	COMPARING ARRAYS AND OBJECTS

An array is a list of data bound to specific index order, the key-value pair is between the item in the array and its index position. 

Therefore if you want to add some item in, you have to specify a position, and that's why you use METHODS (push, pop, shift, unshift), that make this linking easier or automatic.

In objects we talk about FLOATING key-value pairs that have no index but consist of a property and a value. That's why in some languages they talk about DICTIONARIES: {key("word")=value("definition")}.

Since no index is present you can add or remove much easier without methods:

person.lastname = "Raymaekers"

Technically speaking an array is special version of an object, i.e an object with a specific key-value pair.

IS AN OBJECT AN ARRAY?
Check the prototype in the console or use the Object constructor function and call it on the object at hand with the toString method:

var myObject = [1,2,3];
Object.prototype.toString.call(myObject);	//-> "[object Array]"

Array.isArray(myObject);	//-> true

IS A VALUE AN OBJECT?
const bar = {}
bar.constructor === Object	//-> true
typeof bar === "object"	//-> true

NOTE: null is also an object, to avoid this possibility use:

(typeof bar === "object" && bar !== null)

##########################
II.	MODIFYING PROPERTIES
##########################

The . is an operator called the member access operator that accesses members (or properties/methods) in an object.
The [] is called the computed member access. Everything between the brackets is treated a js statement and will invoked or computed.

object.a = true; 	//->changes the existing a property value

console.log(object.d); //->undefined, because does not exist
	
object1.d = 50; //-> adds the property d to the collection of 			properties called object1

DELETE
delete object1.d; //deletes the property d

console.log(object1.d); //-> undefined 

NOTE: delete is a unary operator that only works on object properties, not variables.

If the property is deleted property is no longer present in the object and console.log("d" in object1); will return false. 

var x = { foo : 1};
var output = (function(){
	delete x.foo;
    	return x.foo;
})();
console.log(output);	//-> undefined

If a property is UNDEFINED, this means it is present in the object but has no interesting value attached to it (yet).

	object1.b = undefined;
	console.log("b" in object1); //will return true.

NOTE: in is a binary operator that operates on a string and an object

var x = 1;
var output = (function(){
	delete x;
    	return x;
})();
console.log(output);	//-> 1

var output = (function(x){
	delete x;
    	return x;
})(0);
console.log(output);	//-> 0

The delete operator CANNOT delete prototype properties:

var Employee = {
  company: 'xyz'
}
var emp1 = Object.create(Employee);
delete emp1.company
console.log(emp1.company);	//-> 'xyz'

Because Object.create we have a new instance of the object that does not have a property .company: console.log(emp1.hasOwnProperty('company')) -> false

You have either delete it from the dunder proto in emp1:

delete emp1.__proto__.company

or delete it from the Employee constructor object:

delete Employee.company

DELETE ARRAY INDEX

var arr = ['a', 'b', 'c', 'd'];
arr.length; 	//-> 4
delete arr[2];	//-> true
arr;	//-> ['a', 'b', empty]; 0: 'a', 1:'b', 3: 'd'
arr.length; 	//-> 4

Thus the length of the array is not affected by the delete operator.


####################
III.	OBJECT METHODS
####################

A.	OBJECT KEYS/VALUES
Object.keys method shows you all the properties or keys present inside an object and returns an ARRAY of strings.

	console.log(Object.keys({a:"hello", b:22}));

	// ["property name", "property name"]
	// ["a", "b"]

	object.keys(obj)		//->[keyA, keyB, ..., keyX]
	object.values(obj)	//->[valueA, valB, ..., valX]

or with a FOR...IN loop:

	let arr = [];
	for (let i in obj){arr.push(i)};

The FOR...IN loops over the KEYS only. You get the KEY of the object including things you may have defined in the _proto_.


B.	OBJECT.ASSIGN
Since object names are mere references to the actual object stored in the computers memory, we cannot copy an object by simply assigning another name to an existing object. Thus
var obj1 = {a:1}; var obj2 = obj1; IS NOT A COPY, it is a new reference to the same existing object. 

A copy or clone can be made using Object.assign() which will 
copy/clone all properties from one object into another. Or use the spread operator:
	
	var obj2 = {...obj1};

	var obj2 = Object.assign({}, obj1);

	Object.assign(object1, {d:"boe", e: 33});

	console.log(object1);

		// {a: false , b: 22, c: ["yellow", "red"] , d: "boe", 			e: 33} 

The copying of the unnamed object into the existing object1 happens only ONE LEVEL DEEP. To make a DEEP CLONE you need recursion or a hack:

	const copyObj = json.parse(json.stringify(obj))

First the object is converted into a string and then parses that string into a new object without reference to the original.



C.	FREEZE/SEAL/DEFINE PROPERTY

FREEZE
A frozen object can no longer be changed: No additional properties can be added, values cannot be changed, no deletion of properties and also the prototype cannot be changed.

const obj = {x:1};
Object.freeze(obj)

SEAL
Object.seal(obj);

No new properties can be added but existing values can be changed if the property is writable.

DEFINE PROPERTY
Defines a new property directly on an object, or modifies an existing property on an object, and returns the object.

Object.defineProperty(obj, 'key', descriptor);
const descriptor = {
	value: '';			//value of the key
	writable: false;		//default: false, true: val can change
	configurable: true	//default: false, cannot be deleted
}


D.	CUSTOM OBJECT METHODS

Why use custom object methods? The reason for using methods on objects is to keep code organized and group things together and to avoid namespace collision.

For example, we want to have a function to delete usernames and comments, a general function "delete" could be created but we might want the function to return slightly different feedback and that's not possible. Thus we create methods, functions inside objects, to solve this:

user.delete AND comments.delete
user.createNew AND comments.createNew

All the functions that belong to usernames are grouped together, similar thing for the functions related to comments.

EXAMPLE:
if you create a general function speak that return "Woof", you can only apply it for dogs:

	function speak(){return "Woof"};
	speak(); //returns "Woof"

	function speak(){return "Meow"};
	speak(); //returns "Meow"; The original "Woof" is gone.

If you now add those function to objects they can have the same name but do different things:

var objDog = {}; //empty object

//add an property(or key-value pair):
objDog.speak: function(){return "Woof"};

var objCat = {}; //empty object
//add property:
objCat.speak = function(){return "Meow"};

//call it:
objDog.speak() // returns "Woof";
objCat.speak() // returns "Meow";

PRIVATE METHODS

One of the drawbacks of creating true private methods in JavaScript is that they are very memory-inefficient, as a new copy of the method would be created for each instance.

var Employee = function (name, company, salary) {
    this.name = name || "";       //Public attribute 
    this.company = company || ""; //Public attribute 
    this.salary = salary || 5000; //Public attribute 

    // Private method
    var increaseSalary = function () {
        this.salary = this.salary + 1000;
    };


E.	KEYWORD THIS
In the context of an object with data and METHODS:

var objComments = {
  data: ["well done", "good job", "liked it", "bad"],
  print: function(){
    this.data.forEach(function(item){
      console.log(item);
    })
  }
}
objComments.print()

The keyword this refers to the object objComments! That's how you go from inside "print" to access other properties inside the same object

const obj = {
	a: 1,
	b: 2,
	getA: function(){console.log(this.a)},
	getB() {console.log(this.b)}
}

obj.getA().getB()	//-> TypeError

To make the method chaining work you have to return the object through the keyword this for each method:

const obj = {
	a: 1,
	b: 2,
	getA(){console.log(this.a); return this;},
	getB(){console.log(this.b); return this;}
}
